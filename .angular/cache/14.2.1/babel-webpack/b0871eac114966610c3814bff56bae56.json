{"ast":null,"code":"\"use strict\";\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.object.define-property.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.paste = paste;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nfunction isSupportedElement(element) {\n  return (0, _utils.isElementType)(element, 'input') && Boolean(_utils.editableInputTypes[element.type]) || (0, _utils.isElementType)(element, 'textarea');\n}\n\nfunction paste(element, text, init) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      initialSelectionStart = _ref.initialSelectionStart,\n      initialSelectionEnd = _ref.initialSelectionEnd; // TODO: implement for contenteditable\n\n\n  if (!isSupportedElement(element)) {\n    throw new TypeError(`The given ${element.tagName} element is currently unsupported.\n      A PR extending this implementation would be very much welcome at https://github.com/testing-library/user-event`);\n  }\n\n  if ((0, _utils.isDisabled)(element)) {\n    return;\n  }\n\n  (0, _utils.eventWrapper)(function () {\n    return element.focus();\n  }); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"paste\", they expect it to paste\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n  if (element.selectionStart === 0 && element.selectionEnd === 0) {\n    (0, _utils.setSelectionRange)(element, initialSelectionStart != null ? initialSelectionStart : element.value.length, initialSelectionEnd != null ? initialSelectionEnd : element.value.length);\n  }\n\n  _dom.fireEvent.paste(element, init);\n\n  if (element.readOnly) {\n    return;\n  }\n\n  text = text.substr(0, (0, _utils.getSpaceUntilMaxLength)(element));\n\n  var _ref2 = (0, _utils.calculateNewValue)(text, element),\n      newValue = _ref2.newValue,\n      newSelectionStart = _ref2.newSelectionStart;\n\n  _dom.fireEvent.input(element, {\n    inputType: 'insertFromPaste',\n    target: {\n      value: newValue\n    }\n  });\n\n  (0, _utils.setSelectionRange)(element, // TODO: investigate why the selection caused by invalid parameters was expected\n  {\n    newSelectionStart: newSelectionStart,\n    selectionEnd: newSelectionStart\n  }, {});\n}","map":{"version":3,"mappings":"AAAA;;;;AAEAA,MAAM,CAACC,cAAPD,CAAsBE,OAAtBF,EAA+B,YAA/BA,EAA6C;EAC3CG,KAAK,EAAE;AADoC,CAA7CH;AAGAE,OAAO,CAACE,KAARF,GAAgBE,KAAhBF;;AAEA,IAAIG,IAAI,GAAGC,OAAO,CAAC,sBAAD,CAAlB;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAApB;;AAEA,SAASE,kBAAT,CAA4BC,OAA5B,EAAqC;EACnC,OAAO,CAAC,GAAGF,MAAM,CAACG,aAAX,EAA0BD,OAA1B,EAAmC,OAAnC,KAA+CE,OAAO,CAACJ,MAAM,CAACK,kBAAPL,CAA0BE,OAAO,CAACI,IAAlCN,CAAD,CAAtD,IAAmG,CAAC,GAAGA,MAAM,CAACG,aAAX,EAA0BD,OAA1B,EAAmC,UAAnC,CAA1G;AACD;;AAED,SAASL,KAAT,CAAeK,OAAf,EAAwBK,IAAxB,EAA8BC,IAA9B,EAGQ;EAAA,+EAAJ,EAAI;EAAA,IAFNC,qBAEM,QAFNA,qBAEM;EAAA,IADNC,mBACM,QADNA,mBACM,EACN;;;EACA,IAAI,CAACT,kBAAkB,CAACC,OAAD,CAAvB,EAAkC;IAChC,MAAM,IAAIS,SAAJ,CAAe,aAAYT,OAAO,CAACU,OAAQ;AACrD,qHADU,CAAN;EAED;;EAED,IAAI,CAAC,GAAGZ,MAAM,CAACa,UAAX,EAAuBX,OAAvB,CAAJ,EAAqC;IACnC;EACD;;EAED,CAAC,GAAGF,MAAM,CAACc,YAAX,EAAyB;IAAA,OAAMZ,OAAO,CAACa,KAARb,EAAN;EAAzB,GAXM,CAW2C;EACjD;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAIA,OAAO,CAACc,cAARd,KAA2B,CAA3BA,IAAgCA,OAAO,CAACe,YAARf,KAAyB,CAA7D,EAAgE;IAC9D,CAAC,GAAGF,MAAM,CAACkB,iBAAX,EAA8BhB,OAA9B,EAAuCO,qBAAqB,IAAI,IAAzBA,GAAgCA,qBAAhCA,GAAwDP,OAAO,CAACN,KAARM,CAAciB,MAA7G,EAAqHT,mBAAmB,IAAI,IAAvBA,GAA8BA,mBAA9BA,GAAoDR,OAAO,CAACN,KAARM,CAAciB,MAAvL;EACD;;EAEDrB,IAAI,CAACsB,SAALtB,CAAeD,KAAfC,CAAqBI,OAArBJ,EAA8BU,IAA9BV;;EAEA,IAAII,OAAO,CAACmB,QAAZ,EAAsB;IACpB;EACD;;EAEDd,IAAI,GAAGA,IAAI,CAACe,MAALf,CAAY,CAAZA,EAAe,CAAC,GAAGP,MAAM,CAACuB,sBAAX,EAAmCrB,OAAnC,CAAfK,CAAPA;;EACA,YAGI,CAAC,GAAGP,MAAM,CAACwB,iBAAX,EAA8BjB,IAA9B,EAAoCL,OAApC,CAHJ;EAAA,IACEuB,QADF,SACEA,QADF;EAAA,IAEEC,iBAFF,SAEEA,iBAFF;;EAKA5B,IAAI,CAACsB,SAALtB,CAAe6B,KAAf7B,CAAqBI,OAArBJ,EAA8B;IAC5B8B,SAAS,EAAE,iBADiB;IAE5BC,MAAM,EAAE;MACNjC,KAAK,EAAE6B;IADD;EAFoB,CAA9B3B;;EAOA,CAAC,GAAGE,MAAM,CAACkB,iBAAX,EAA8BhB,OAA9B,EAAuC;EACvC;IACEwB,iBAAiB,EAAjBA,iBADF;IAEET,YAAY,EAAES;EAFhB,CADA,EAIG,EAJH;AAKD","names":["Object","defineProperty","exports","value","paste","_dom","require","_utils","isSupportedElement","element","isElementType","Boolean","editableInputTypes","type","text","init","initialSelectionStart","initialSelectionEnd","TypeError","tagName","isDisabled","eventWrapper","focus","selectionStart","selectionEnd","setSelectionRange","length","fireEvent","readOnly","substr","getSpaceUntilMaxLength","calculateNewValue","newValue","newSelectionStart","input","inputType","target"],"sources":["/Users/ilze/Documents/git/ng-iz/node_modules/@testing-library/user-event/dist/paste.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.paste = paste;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nfunction isSupportedElement(element) {\n  return (0, _utils.isElementType)(element, 'input') && Boolean(_utils.editableInputTypes[element.type]) || (0, _utils.isElementType)(element, 'textarea');\n}\n\nfunction paste(element, text, init, {\n  initialSelectionStart,\n  initialSelectionEnd\n} = {}) {\n  // TODO: implement for contenteditable\n  if (!isSupportedElement(element)) {\n    throw new TypeError(`The given ${element.tagName} element is currently unsupported.\n      A PR extending this implementation would be very much welcome at https://github.com/testing-library/user-event`);\n  }\n\n  if ((0, _utils.isDisabled)(element)) {\n    return;\n  }\n\n  (0, _utils.eventWrapper)(() => element.focus()); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"paste\", they expect it to paste\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n  if (element.selectionStart === 0 && element.selectionEnd === 0) {\n    (0, _utils.setSelectionRange)(element, initialSelectionStart != null ? initialSelectionStart : element.value.length, initialSelectionEnd != null ? initialSelectionEnd : element.value.length);\n  }\n\n  _dom.fireEvent.paste(element, init);\n\n  if (element.readOnly) {\n    return;\n  }\n\n  text = text.substr(0, (0, _utils.getSpaceUntilMaxLength)(element));\n  const {\n    newValue,\n    newSelectionStart\n  } = (0, _utils.calculateNewValue)(text, element);\n\n  _dom.fireEvent.input(element, {\n    inputType: 'insertFromPaste',\n    target: {\n      value: newValue\n    }\n  });\n\n  (0, _utils.setSelectionRange)(element, // TODO: investigate why the selection caused by invalid parameters was expected\n  {\n    newSelectionStart,\n    selectionEnd: newSelectionStart\n  }, {});\n}"]},"metadata":{},"sourceType":"script"}