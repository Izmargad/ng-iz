{"ast":null,"code":"\"use strict\";\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.object.define-property.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.object.assign.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.symbol.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.symbol.description.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.object.to-string.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fireInputEvent = fireInputEvent;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"../../utils\");\n\nfunction fireInputEvent(element, _ref) {\n  var newValue = _ref.newValue,\n      newSelectionStart = _ref.newSelectionStart,\n      eventOverrides = _ref.eventOverrides; // apply the changes before firing the input event, so that input handlers can access the altered dom and selection\n\n  if ((0, _utils.isContentEditable)(element)) {\n    applyNative(element, 'textContent', newValue);\n  } else\n    /* istanbul ignore else */\n    if ((0, _utils.isElementType)(element, ['input', 'textarea'])) {\n      applyNative(element, 'value', newValue);\n    } else {\n      // TODO: properly type guard\n      throw new Error('Invalid Element');\n    }\n\n  setSelectionRangeAfterInput(element, newSelectionStart);\n\n  _dom.fireEvent.input(element, Object.assign({}, eventOverrides));\n\n  setSelectionRangeAfterInputHandler(element, newValue, newSelectionStart);\n}\n\nfunction setSelectionRangeAfterInput(element, newSelectionStart) {\n  (0, _utils.setSelectionRange)(element, newSelectionStart, newSelectionStart);\n}\n\nfunction setSelectionRangeAfterInputHandler(element, newValue, newSelectionStart) {\n  var value = (0, _utils.getValue)(element); // don't apply this workaround on elements that don't necessarily report the visible value - e.g. number\n  // TODO: this could probably be only applied when there is keyboardState.carryValue\n\n  var isUnreliableValue = value === '' && (0, _utils.hasUnreliableEmptyValue)(element);\n\n  if (!isUnreliableValue && value === newValue) {\n    var _ref2 = (0, _utils.getSelectionRange)(element),\n        selectionStart = _ref2.selectionStart;\n\n    if (selectionStart === value.length) {\n      // The value was changed as expected, but the cursor was moved to the end\n      // TODO: this could probably be only applied when we work around a framework setter on the element in applyNative\n      (0, _utils.setSelectionRange)(element, newSelectionStart, newSelectionStart);\n    }\n  }\n}\n\nvar initial = Symbol('initial input value/textContent');\nvar onBlur = Symbol('onBlur');\n/**\n * React tracks the changes on element properties.\n * This workaround tries to alter the DOM element without React noticing,\n * so that it later picks up the change.\n *\n * @see https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-dom/src/client/inputValueTracking.js#L51-L104\n */\n\nfunction applyNative(element, propName, propValue) {\n  var descriptor = Object.getOwnPropertyDescriptor(element, propName);\n  var nativeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName);\n\n  if (descriptor && nativeDescriptor) {\n    Object.defineProperty(element, propName, nativeDescriptor);\n  } // Keep track of the initial value to determine if a change event should be dispatched.\n  // CONSTRAINT: We can not determine what happened between focus event and our first API call.\n\n\n  if (element[initial] === undefined) {\n    element[initial] = String(element[propName]);\n  }\n\n  element[propName] = propValue; // Add an event listener for the blur event to the capture phase on the window.\n  // CONSTRAINT: Currently there is no cross-platform solution to unshift the event handler stack.\n  // Our change event might occur after other event handlers on the blur event have been processed.\n\n  if (!element[onBlur]) {\n    var _element$ownerDocumen;\n\n    (_element$ownerDocumen = element.ownerDocument.defaultView) == null ? void 0 : _element$ownerDocumen.addEventListener('blur', element[onBlur] = function () {\n      var initV = element[initial]; // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n\n      delete element[onBlur]; // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n\n      delete element[initial];\n\n      if (String(element[propName]) !== initV) {\n        _dom.fireEvent.change(element);\n      }\n    }, {\n      capture: true,\n      once: true\n    });\n  }\n\n  if (descriptor) {\n    Object.defineProperty(element, propName, descriptor);\n  }\n}","map":{"version":3,"mappings":"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","names":["Object","defineProperty","exports","value","fireInputEvent","_dom","require","_utils","element","newValue","newSelectionStart","eventOverrides","isContentEditable","applyNative","isElementType","Error","setSelectionRangeAfterInput","fireEvent","input","setSelectionRangeAfterInputHandler","setSelectionRange","getValue","isUnreliableValue","hasUnreliableEmptyValue","getSelectionRange","selectionStart","length","initial","Symbol","onBlur","propName","propValue","descriptor","getOwnPropertyDescriptor","nativeDescriptor","constructor","prototype","undefined","String","_element$ownerDocumen","ownerDocument","defaultView","addEventListener","initV","change","capture","once"],"sources":["/Users/ilze/Documents/git/ng-iz/node_modules/@testing-library/user-event/dist/keyboard/shared/fireInputEvent.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fireInputEvent = fireInputEvent;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"../../utils\");\n\nfunction fireInputEvent(element, {\n  newValue,\n  newSelectionStart,\n  eventOverrides\n}) {\n  // apply the changes before firing the input event, so that input handlers can access the altered dom and selection\n  if ((0, _utils.isContentEditable)(element)) {\n    applyNative(element, 'textContent', newValue);\n  } else\n    /* istanbul ignore else */\n    if ((0, _utils.isElementType)(element, ['input', 'textarea'])) {\n      applyNative(element, 'value', newValue);\n    } else {\n      // TODO: properly type guard\n      throw new Error('Invalid Element');\n    }\n\n  setSelectionRangeAfterInput(element, newSelectionStart);\n\n  _dom.fireEvent.input(element, { ...eventOverrides\n  });\n\n  setSelectionRangeAfterInputHandler(element, newValue, newSelectionStart);\n}\n\nfunction setSelectionRangeAfterInput(element, newSelectionStart) {\n  (0, _utils.setSelectionRange)(element, newSelectionStart, newSelectionStart);\n}\n\nfunction setSelectionRangeAfterInputHandler(element, newValue, newSelectionStart) {\n  const value = (0, _utils.getValue)(element); // don't apply this workaround on elements that don't necessarily report the visible value - e.g. number\n  // TODO: this could probably be only applied when there is keyboardState.carryValue\n\n  const isUnreliableValue = value === '' && (0, _utils.hasUnreliableEmptyValue)(element);\n\n  if (!isUnreliableValue && value === newValue) {\n    const {\n      selectionStart\n    } = (0, _utils.getSelectionRange)(element);\n\n    if (selectionStart === value.length) {\n      // The value was changed as expected, but the cursor was moved to the end\n      // TODO: this could probably be only applied when we work around a framework setter on the element in applyNative\n      (0, _utils.setSelectionRange)(element, newSelectionStart, newSelectionStart);\n    }\n  }\n}\n\nconst initial = Symbol('initial input value/textContent');\nconst onBlur = Symbol('onBlur');\n\n/**\n * React tracks the changes on element properties.\n * This workaround tries to alter the DOM element without React noticing,\n * so that it later picks up the change.\n *\n * @see https://github.com/facebook/react/blob/148f8e497c7d37a3c7ab99f01dec2692427272b1/packages/react-dom/src/client/inputValueTracking.js#L51-L104\n */\nfunction applyNative(element, propName, propValue) {\n  const descriptor = Object.getOwnPropertyDescriptor(element, propName);\n  const nativeDescriptor = Object.getOwnPropertyDescriptor(element.constructor.prototype, propName);\n\n  if (descriptor && nativeDescriptor) {\n    Object.defineProperty(element, propName, nativeDescriptor);\n  } // Keep track of the initial value to determine if a change event should be dispatched.\n  // CONSTRAINT: We can not determine what happened between focus event and our first API call.\n\n\n  if (element[initial] === undefined) {\n    element[initial] = String(element[propName]);\n  }\n\n  element[propName] = propValue; // Add an event listener for the blur event to the capture phase on the window.\n  // CONSTRAINT: Currently there is no cross-platform solution to unshift the event handler stack.\n  // Our change event might occur after other event handlers on the blur event have been processed.\n\n  if (!element[onBlur]) {\n    var _element$ownerDocumen;\n\n    (_element$ownerDocumen = element.ownerDocument.defaultView) == null ? void 0 : _element$ownerDocumen.addEventListener('blur', element[onBlur] = () => {\n      const initV = element[initial]; // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n\n      delete element[onBlur]; // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n\n      delete element[initial];\n\n      if (String(element[propName]) !== initV) {\n        _dom.fireEvent.change(element);\n      }\n    }, {\n      capture: true,\n      once: true\n    });\n  }\n\n  if (descriptor) {\n    Object.defineProperty(element, propName, descriptor);\n  }\n}"]},"metadata":{},"sourceType":"script"}