{"ast":null,"code":"\"use strict\";\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.object.define-property.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.string.repeat.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.array.find.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.string.match.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.regexp.exec.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.regexp.constructor.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.object.assign.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.array.slice.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.array.join.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.array.filter.js\");\n\nrequire(\"/Users/ilze/Documents/git/ng-iz/node_modules/core-js/modules/es.number.constructor.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextKeyDef = getNextKeyDef;\nvar bracketDict;\n\n(function (bracketDict) {\n  bracketDict[\"{\"] = \"}\";\n  bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\n\nvar legacyModifiers;\n\n(function (legacyModifiers) {\n  legacyModifiers[\"alt\"] = \"alt\";\n  legacyModifiers[\"ctrl\"] = \"ctrl\";\n  legacyModifiers[\"meta\"] = \"meta\";\n  legacyModifiers[\"shift\"] = \"shift\";\n})(legacyModifiers || (legacyModifiers = {}));\n\nvar legacyKeyMap;\n/**\n * Get the next key from keyMap\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n * Modifiers like `{shift}` imply being kept pressed. This can be turned of per `{shift/}`.\n */\n\n(function (legacyKeyMap) {\n  legacyKeyMap[\"ctrl\"] = \"Control\";\n  legacyKeyMap[\"del\"] = \"Delete\";\n  legacyKeyMap[\"esc\"] = \"Escape\";\n  legacyKeyMap[\"space\"] = \" \";\n})(legacyKeyMap || (legacyKeyMap = {}));\n\nfunction getNextKeyDef(text, options) {\n  var _options$keyboardMap$;\n\n  var _readNextDescriptor = readNextDescriptor(text),\n      type = _readNextDescriptor.type,\n      descriptor = _readNextDescriptor.descriptor,\n      consumedLength = _readNextDescriptor.consumedLength,\n      releasePrevious = _readNextDescriptor.releasePrevious,\n      releaseSelf = _readNextDescriptor.releaseSelf,\n      repeat = _readNextDescriptor.repeat;\n\n  var keyDef = (_options$keyboardMap$ = options.keyboardMap.find(function (def) {\n    if (type === '[') {\n      var _def$code;\n\n      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();\n    } else if (type === '{') {\n      var _def$key;\n\n      var key = mapLegacyKey(descriptor);\n      return ((_def$key = def.key) == null ? void 0 : _def$key.toLowerCase()) === key.toLowerCase();\n    }\n\n    return def.key === descriptor;\n  })) != null ? _options$keyboardMap$ : {\n    key: 'Unknown',\n    code: 'Unknown',\n    [type === '[' ? 'code' : 'key']: descriptor\n  };\n  return {\n    keyDef: keyDef,\n    consumedLength: consumedLength,\n    releasePrevious: releasePrevious,\n    releaseSelf: releaseSelf,\n    repeat: repeat\n  };\n}\n\nfunction readNextDescriptor(text) {\n  var pos = 0;\n  var startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length; // `foo{{bar` is an escaped char at position 3,\n  // but `foo{{{>5}bar` should be treated as `{` pressed down for 5 keydowns.\n\n  var startBracketRepeated = startBracket ? text.match(new RegExp(`^\\\\${startBracket}+`))[0].length : 0;\n  var isEscapedChar = startBracketRepeated === 2 || startBracket === '{' && startBracketRepeated > 3;\n  var type = isEscapedChar ? '' : startBracket;\n  return Object.assign({\n    type: type\n  }, type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type));\n}\n\nfunction readPrintableChar(text, pos) {\n  var descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor: descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\n\nfunction readTag(text, pos, startBracket) {\n  var _text$slice$match, _text$slice$match$, _text$slice$match2;\n\n  var releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  var descriptor = (_text$slice$match = text.slice(pos).match(/^\\w+/)) == null ? void 0 : _text$slice$match[0];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  var repeatModifier = (_text$slice$match$ = (_text$slice$match2 = text.slice(pos).match(/^>\\d+/)) == null ? void 0 : _text$slice$match2[0]) != null ? _text$slice$match$ : '';\n  pos += repeatModifier.length;\n  var releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  var expectedEndBracket = bracketDict[startBracket];\n  var endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `\"${expectedEndBracket}\"`].filter(Boolean).join(' or '), text[pos], text));\n  }\n\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor: descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier)\n  };\n}\n\nfunction assertDescriptor(descriptor, text, pos) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text));\n  }\n}\n\nfunction getEnumValue(f, key) {\n  return f[key];\n}\n\nfunction hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n\n  if (repeatModifier) {\n    return false;\n  }\n\n  if (startBracket === '{' && getEnumValue(legacyModifiers, descriptor.toLowerCase())) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction mapLegacyKey(descriptor) {\n  var _getEnumValue;\n\n  return (_getEnumValue = getEnumValue(legacyKeyMap, descriptor)) != null ? _getEnumValue : descriptor;\n}\n\nfunction getErrorMessage(expected, found, text) {\n  return `Expected ${expected} but found \"${found != null ? found : ''}\" in \"${text}\"\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\n    for more information about how userEvent parses your input.`;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAEAA,MAAM,CAACC,cAAPD,CAAsBE,OAAtBF,EAA+B,YAA/BA,EAA6C;EAC3CG,KAAK,EAAE;AADoC,CAA7CH;AAGAE,OAAO,CAACE,aAARF,GAAwBE,aAAxBF;AACA,IAAIG,WAAJ;;AAEA,CAAC,UAAUA,WAAV,EAAuB;EACtBA,WAAW,CAAC,GAAD,CAAXA,GAAmB,GAAnBA;EACAA,WAAW,CAAC,GAAD,CAAXA,GAAmB,GAAnBA;AAFF,GAGGA,WAAW,KAAKA,WAAW,GAAG,EAAnB,CAHd;;AAKA,IAAIC,eAAJ;;AAEA,CAAC,UAAUA,eAAV,EAA2B;EAC1BA,eAAe,CAAC,KAAD,CAAfA,GAAyB,KAAzBA;EACAA,eAAe,CAAC,MAAD,CAAfA,GAA0B,MAA1BA;EACAA,eAAe,CAAC,MAAD,CAAfA,GAA0B,MAA1BA;EACAA,eAAe,CAAC,OAAD,CAAfA,GAA2B,OAA3BA;AAJF,GAKGA,eAAe,KAAKA,eAAe,GAAG,EAAvB,CALlB;;AAOA,IAAIC,YAAJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,UAAUA,YAAV,EAAwB;EACvBA,YAAY,CAAC,MAAD,CAAZA,GAAuB,SAAvBA;EACAA,YAAY,CAAC,KAAD,CAAZA,GAAsB,QAAtBA;EACAA,YAAY,CAAC,KAAD,CAAZA,GAAsB,QAAtBA;EACAA,YAAY,CAAC,OAAD,CAAZA,GAAwB,GAAxBA;AAJF,GAKGA,YAAY,KAAKA,YAAY,GAAG,EAApB,CALf;;AAOA,SAASH,aAAT,CAAuBI,IAAvB,EAA6BC,OAA7B,EAAsC;EACpC,IAAIC,qBAAJ;;EAEA,0BAOIC,kBAAkB,CAACH,IAAD,CAPtB;EAAA,IACEI,IADF,uBACEA,IADF;EAAA,IAEEC,UAFF,uBAEEA,UAFF;EAAA,IAGEC,cAHF,uBAGEA,cAHF;EAAA,IAIEC,eAJF,uBAIEA,eAJF;EAAA,IAKEC,WALF,uBAKEA,WALF;EAAA,IAMEC,MANF,uBAMEA,MANF;;EAQA,IAAMC,MAAM,GAAG,CAACR,qBAAqB,GAAGD,OAAO,CAACU,WAARV,CAAoBW,IAApBX,CAAyB,eAAO;IACtE,IAAIG,IAAI,KAAK,GAAb,EAAkB;MAChB,IAAIS,SAAJ;;MAEA,OAAO,CAAC,CAACA,SAAS,GAAGC,GAAG,CAACC,IAAjB,KAA0B,IAA1B,GAAiC,KAAK,CAAtC,GAA0CF,SAAS,CAACG,WAAVH,EAA3C,MAAwER,UAAU,CAACW,WAAXX,EAA/E;IAHF,OAIO,IAAID,IAAI,KAAK,GAAb,EAAkB;MACvB,IAAIa,QAAJ;;MAEA,IAAMC,GAAG,GAAGC,YAAY,CAACd,UAAD,CAAxB;MACA,OAAO,CAAC,CAACY,QAAQ,GAAGH,GAAG,CAACI,GAAhB,KAAwB,IAAxB,GAA+B,KAAK,CAApC,GAAwCD,QAAQ,CAACD,WAATC,EAAzC,MAAqEC,GAAG,CAACF,WAAJE,EAA5E;IACD;;IAED,OAAOJ,GAAG,CAACI,GAAJJ,KAAYT,UAAnB;EAZsC,EAAzB,KAaR,IAbQ,GAaDH,qBAbC,GAauB;IACpCgB,GAAG,EAAE,SAD+B;IAEpCH,IAAI,EAAE,SAF8B;IAGpC,CAACX,IAAI,KAAK,GAATA,GAAe,MAAfA,GAAwB,KAAzB,GAAiCC;EAHG,CAbtC;EAkBA,OAAO;IACLK,MAAM,EAANA,MADK;IAELJ,cAAc,EAAdA,cAFK;IAGLC,eAAe,EAAfA,eAHK;IAILC,WAAW,EAAXA,WAJK;IAKLC,MAAM,EAANA;EALK,CAAP;AAOD;;AAED,SAASN,kBAAT,CAA4BH,IAA5B,EAAkC;EAChC,IAAIoB,GAAG,GAAG,CAAV;EACA,IAAMC,YAAY,GAAGrB,IAAI,CAACoB,GAAD,CAAJpB,IAAaH,WAAbG,GAA2BA,IAAI,CAACoB,GAAD,CAA/BpB,GAAuC,EAA5D;EACAoB,GAAG,IAAIC,YAAY,CAACC,MAApBF,CAHgC,CAGJ;EAC5B;;EAEA,IAAMG,oBAAoB,GAAGF,YAAY,GAAGrB,IAAI,CAACwB,KAALxB,CAAW,IAAIyB,MAAJ,CAAY,MAAKJ,YAAa,GAA9B,CAAXrB,EAA8C,CAA9CA,EAAiDsB,MAApD,GAA6D,CAAtG;EACA,IAAMI,aAAa,GAAGH,oBAAoB,KAAK,CAAzBA,IAA8BF,YAAY,KAAK,GAAjBA,IAAwBE,oBAAoB,GAAG,CAAnG;EACA,IAAMnB,IAAI,GAAGsB,aAAa,GAAG,EAAH,GAAQL,YAAlC;EACA;IACEjB,IAAI,EAAJA;EADF,GAEMA,IAAI,KAAK,EAATA,GAAcuB,iBAAiB,CAAC3B,IAAD,EAAOoB,GAAP,CAA/BhB,GAA6CwB,OAAO,CAAC5B,IAAD,EAAOoB,GAAP,EAAYhB,IAAZ,CAF1D;AAID;;AAED,SAASuB,iBAAT,CAA2B3B,IAA3B,EAAiCoB,GAAjC,EAAsC;EACpC,IAAMf,UAAU,GAAGL,IAAI,CAACoB,GAAD,CAAvB;EACAS,gBAAgB,CAACxB,UAAD,EAAaL,IAAb,EAAmBoB,GAAnB,CAAhBS;EACAT,GAAG,IAAIf,UAAU,CAACiB,MAAlBF;EACA,OAAO;IACLd,cAAc,EAAEc,GADX;IAELf,UAAU,EAAVA,UAFK;IAGLE,eAAe,EAAE,KAHZ;IAILC,WAAW,EAAE,IAJR;IAKLC,MAAM,EAAE;EALH,CAAP;AAOD;;AAED,SAASmB,OAAT,CAAiB5B,IAAjB,EAAuBoB,GAAvB,EAA4BC,YAA5B,EAA0C;EACxC,IAAIS,iBAAJ,EAAuBC,kBAAvB,EAA2CC,kBAA3C;;EAEA,IAAMC,uBAAuB,GAAGjC,IAAI,CAACoB,GAAD,CAAJpB,KAAc,GAAdA,GAAoB,GAApBA,GAA0B,EAA1D;EACAoB,GAAG,IAAIa,uBAAuB,CAACX,MAA/BF;EACA,IAAMf,UAAU,GAAG,CAACyB,iBAAiB,GAAG9B,IAAI,CAACkC,KAALlC,CAAWoB,GAAXpB,EAAgBwB,KAAhBxB,CAAsB,MAAtBA,CAArB,KAAuD,IAAvD,GAA8D,KAAK,CAAnE,GAAuE8B,iBAAiB,CAAC,CAAD,CAA3G;EACAD,gBAAgB,CAACxB,UAAD,EAAaL,IAAb,EAAmBoB,GAAnB,CAAhBS;EACAT,GAAG,IAAIf,UAAU,CAACiB,MAAlBF;EACA,IAAMe,cAAc,GAAG,CAACJ,kBAAkB,GAAG,CAACC,kBAAkB,GAAGhC,IAAI,CAACkC,KAALlC,CAAWoB,GAAXpB,EAAgBwB,KAAhBxB,CAAsB,OAAtBA,CAAtB,KAAyD,IAAzD,GAAgE,KAAK,CAArE,GAAyEgC,kBAAkB,CAAC,CAAD,CAAjH,KAAyH,IAAzH,GAAgID,kBAAhI,GAAqJ,EAA5K;EACAX,GAAG,IAAIe,cAAc,CAACb,MAAtBF;EACA,IAAMgB,mBAAmB,GAAGpC,IAAI,CAACoB,GAAD,CAAJpB,KAAc,GAAdA,IAAqB,CAACmC,cAAD,IAAmBnC,IAAI,CAACoB,GAAD,CAAJpB,KAAc,GAAtDA,GAA4DA,IAAI,CAACoB,GAAD,CAAhEpB,GAAwE,EAApG;EACAoB,GAAG,IAAIgB,mBAAmB,CAACd,MAA3BF;EACA,IAAMiB,kBAAkB,GAAGxC,WAAW,CAACwB,YAAD,CAAtC;EACA,IAAMiB,UAAU,GAAGtC,IAAI,CAACoB,GAAD,CAAJpB,KAAcqC,kBAAdrC,GAAmCqC,kBAAnCrC,GAAwD,EAA3E;;EAEA,IAAI,CAACsC,UAAL,EAAiB;IACf,MAAM,IAAIC,KAAJ,CAAUC,eAAe,CAAC,CAAC,CAACL,cAAD,IAAmB,iBAApB,EAAuC,CAACC,mBAAD,IAAwB,kBAA/D,EAAoF,IAAGC,kBAAmB,GAA1G,EAA8GI,MAA9G,CAAqHC,OAArH,EAA8HC,IAA9H,CAAmI,MAAnI,CAAD,EAA6I3C,IAAI,CAACoB,GAAD,CAAjJ,EAAwJpB,IAAxJ,CAAzB,CAAN;EACD;;EAEDoB,GAAG,IAAIkB,UAAU,CAAChB,MAAlBF;EACA,OAAO;IACLd,cAAc,EAAEc,GADX;IAELf,UAAU,EAAVA,UAFK;IAGLE,eAAe,EAAE,CAAC,CAAC0B,uBAHd;IAILxB,MAAM,EAAE0B,cAAc,GAAGS,IAAI,CAACC,GAALD,CAASE,MAAM,CAACX,cAAc,CAACY,MAAfZ,CAAsB,CAAtBA,CAAD,CAAfS,EAA2C,CAA3CA,CAAH,GAAmD,CAJpE;IAKLpC,WAAW,EAAEwC,cAAc,CAAC3B,YAAD,EAAehB,UAAf,EAA2B+B,mBAA3B,EAAgDD,cAAhD;EALtB,CAAP;AAOD;;AAED,SAASN,gBAAT,CAA0BxB,UAA1B,EAAsCL,IAAtC,EAA4CoB,GAA5C,EAAiD;EAC/C,IAAI,CAACf,UAAL,EAAiB;IACf,MAAM,IAAIkC,KAAJ,CAAUC,eAAe,CAAC,gBAAD,EAAmBxC,IAAI,CAACoB,GAAD,CAAvB,EAA8BpB,IAA9B,CAAzB,CAAN;EACD;AACF;;AAED,SAASiD,YAAT,CAAsBC,CAAtB,EAAyBhC,GAAzB,EAA8B;EAC5B,OAAOgC,CAAC,CAAChC,GAAD,CAAR;AACD;;AAED,SAAS8B,cAAT,CAAwB3B,YAAxB,EAAsChB,UAAtC,EAAkD+B,mBAAlD,EAAuED,cAAvE,EAAuF;EACrF,IAAIC,mBAAJ,EAAyB;IACvB,OAAOA,mBAAmB,KAAK,GAA/B;EACD;;EAED,IAAID,cAAJ,EAAoB;IAClB,OAAO,KAAP;EACD;;EAED,IAAId,YAAY,KAAK,GAAjBA,IAAwB4B,YAAY,CAACnD,eAAD,EAAkBO,UAAU,CAACW,WAAXX,EAAlB,CAAxC,EAAqF;IACnF,OAAO,KAAP;EACD;;EAED,OAAO,IAAP;AACD;;AAED,SAASc,YAAT,CAAsBd,UAAtB,EAAkC;EAChC,IAAI8C,aAAJ;;EAEA,OAAO,CAACA,aAAa,GAAGF,YAAY,CAAClD,YAAD,EAAeM,UAAf,CAA7B,KAA4D,IAA5D,GAAmE8C,aAAnE,GAAmF9C,UAA1F;AACD;;AAED,SAASmC,eAAT,CAAyBY,QAAzB,EAAmCC,KAAnC,EAA0CrD,IAA1C,EAAgD;EAC9C,OAAQ,YAAWoD,QAAS,eAAcC,KAAK,IAAI,IAATA,GAAgBA,KAAhBA,GAAwB,EAAG,SAAQrD,IAAK;AACpF;AACA,gEAFE;AAGD","names":["Object","defineProperty","exports","value","getNextKeyDef","bracketDict","legacyModifiers","legacyKeyMap","text","options","_options$keyboardMap$","readNextDescriptor","type","descriptor","consumedLength","releasePrevious","releaseSelf","repeat","keyDef","keyboardMap","find","_def$code","def","code","toLowerCase","_def$key","key","mapLegacyKey","pos","startBracket","length","startBracketRepeated","match","RegExp","isEscapedChar","readPrintableChar","readTag","assertDescriptor","_text$slice$match","_text$slice$match$","_text$slice$match2","releasePreviousModifier","slice","repeatModifier","releaseSelfModifier","expectedEndBracket","endBracket","Error","getErrorMessage","filter","Boolean","join","Math","max","Number","substr","hasReleaseSelf","getEnumValue","f","_getEnumValue","expected","found"],"sources":["/Users/ilze/Documents/git/ng-iz/node_modules/@testing-library/user-event/dist/keyboard/getNextKeyDef.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextKeyDef = getNextKeyDef;\nvar bracketDict;\n\n(function (bracketDict) {\n  bracketDict[\"{\"] = \"}\";\n  bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\n\nvar legacyModifiers;\n\n(function (legacyModifiers) {\n  legacyModifiers[\"alt\"] = \"alt\";\n  legacyModifiers[\"ctrl\"] = \"ctrl\";\n  legacyModifiers[\"meta\"] = \"meta\";\n  legacyModifiers[\"shift\"] = \"shift\";\n})(legacyModifiers || (legacyModifiers = {}));\n\nvar legacyKeyMap;\n/**\n * Get the next key from keyMap\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n * Modifiers like `{shift}` imply being kept pressed. This can be turned of per `{shift/}`.\n */\n\n(function (legacyKeyMap) {\n  legacyKeyMap[\"ctrl\"] = \"Control\";\n  legacyKeyMap[\"del\"] = \"Delete\";\n  legacyKeyMap[\"esc\"] = \"Escape\";\n  legacyKeyMap[\"space\"] = \" \";\n})(legacyKeyMap || (legacyKeyMap = {}));\n\nfunction getNextKeyDef(text, options) {\n  var _options$keyboardMap$;\n\n  const {\n    type,\n    descriptor,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  } = readNextDescriptor(text);\n  const keyDef = (_options$keyboardMap$ = options.keyboardMap.find(def => {\n    if (type === '[') {\n      var _def$code;\n\n      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();\n    } else if (type === '{') {\n      var _def$key;\n\n      const key = mapLegacyKey(descriptor);\n      return ((_def$key = def.key) == null ? void 0 : _def$key.toLowerCase()) === key.toLowerCase();\n    }\n\n    return def.key === descriptor;\n  })) != null ? _options$keyboardMap$ : {\n    key: 'Unknown',\n    code: 'Unknown',\n    [type === '[' ? 'code' : 'key']: descriptor\n  };\n  return {\n    keyDef,\n    consumedLength,\n    releasePrevious,\n    releaseSelf,\n    repeat\n  };\n}\n\nfunction readNextDescriptor(text) {\n  let pos = 0;\n  const startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length; // `foo{{bar` is an escaped char at position 3,\n  // but `foo{{{>5}bar` should be treated as `{` pressed down for 5 keydowns.\n\n  const startBracketRepeated = startBracket ? text.match(new RegExp(`^\\\\${startBracket}+`))[0].length : 0;\n  const isEscapedChar = startBracketRepeated === 2 || startBracket === '{' && startBracketRepeated > 3;\n  const type = isEscapedChar ? '' : startBracket;\n  return {\n    type,\n    ...(type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type))\n  };\n}\n\nfunction readPrintableChar(text, pos) {\n  const descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\n\nfunction readTag(text, pos, startBracket) {\n  var _text$slice$match, _text$slice$match$, _text$slice$match2;\n\n  const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  const descriptor = (_text$slice$match = text.slice(pos).match(/^\\w+/)) == null ? void 0 : _text$slice$match[0];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  const repeatModifier = (_text$slice$match$ = (_text$slice$match2 = text.slice(pos).match(/^>\\d+/)) == null ? void 0 : _text$slice$match2[0]) != null ? _text$slice$match$ : '';\n  pos += repeatModifier.length;\n  const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  const expectedEndBracket = bracketDict[startBracket];\n  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `\"${expectedEndBracket}\"`].filter(Boolean).join(' or '), text[pos], text));\n  }\n\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier)\n  };\n}\n\nfunction assertDescriptor(descriptor, text, pos) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text));\n  }\n}\n\nfunction getEnumValue(f, key) {\n  return f[key];\n}\n\nfunction hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n\n  if (repeatModifier) {\n    return false;\n  }\n\n  if (startBracket === '{' && getEnumValue(legacyModifiers, descriptor.toLowerCase())) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction mapLegacyKey(descriptor) {\n  var _getEnumValue;\n\n  return (_getEnumValue = getEnumValue(legacyKeyMap, descriptor)) != null ? _getEnumValue : descriptor;\n}\n\nfunction getErrorMessage(expected, found, text) {\n  return `Expected ${expected} but found \"${found != null ? found : ''}\" in \"${text}\"\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\n    for more information about how userEvent parses your input.`;\n}"]},"metadata":{},"sourceType":"script"}